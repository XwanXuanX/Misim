# Instruction Set Design


## Introduction

It's time to make a change!

Although the existing instruction set works fine, it is necessary to sit back and rethink whether it is truly optimal. From the current point of view, there are several obvious drawbacks in the existing instruction set, which prevents from further software development. The goal is to optimize and fix each drawbacks respectively, and redefine the new instruction set, similar to RISC-V instruction set.

This document is meant to record the evolution of own instruction set(s). The following topics will be covered:
1. __drawback__ of existing instruction set;
2. __principle__ of designing the new instruction set;
3. The proposed new __instruction set__;
4. The proposed new __instruction encoding__;
5. __Differences__ between new and old IS and reasons to change;
6. Future __improvements__;
7. Appendix: A __detailed analysis__ for each instruction, and how other operations can be generated by the superposition of others.


## Drawback of existing instruction set

Here is a full reference of original instruction set:
```
Arithmetic: ADD, UMUL, UDIV, UMOL
Logic:      AND, ORR, XOR, SHL, SHR, RTL, RTR, NOT
Memory:     LDR, STR, PUSH, POP,
Branching:  JMP, JZ, JC, JV, JZN, JN, SYSCALL
```

There are several drawbacks that can be concluded:
* __Redundant or unnecessary instructions__: Some instructions are redundant or unnecessary. For instance, the `PUSH` and `POP` commands can be simply implemented via several combinations of `ADD`, `STR`, `LDR` commands. One better proposed design is letting `PUSH` and `POP` be sudo-commands, which are provided by the assembler. The assembler will generate the corresponding sequences of actual machine instruction to perform the job.

* __Lack of signed integer support__: The original instruction set does not have arithmetic operation for signed integers at all. All the arithmetic operations (e.g. `ADD`, `UMUL`, `UDIV`, `UMOL`) are done using unsigned integers, or in other words, the underlying bit representations for signed integers. This is inconvenient, since to perform signed integers subtraction, one has to perform 2's compliment on one integer then call `ADD` operation on two integers, for example.

* __Lack of other kinds of load instructions__: The original instruction set has one load instruction: `LDR`. This instruction will load entire memory slot into a register. However, this is completely different from what's happening in real life. For simplicity sake, I simplify the memory model to array of integers with various size, while the actual computer memory only consists of a sequence of byte. The system bit and endianness are independent of memory model. Therefore, more load/store instructions are needed to indicate the size of operation (e.g. byte, half-word, or word).

* __Confusing and (almost) unnecessary OpType__: Instructions in current instruction set are classified into 5 types of instructions: `R type`, `I type`, `U type`, `J type`, `S type`. However, within those 5 types, only 1 type is actually used to differentiate instructions. Thus, the others are not necessary. According to the RISC-V instruction set design, they classify instructions into different classes because they define different encodings for each instruction type. However, in my design, all instructions share a common encoding, thus there is no need to classify types.

* __Operation on register and immediate share same OpCode__: In the original instruction set, an operation that can take in a register or an immediate share the same OpCode (e.g. `ADD R1, R2, R3` and `ADD R1, R2, 42`). It's not a huge issue, but definitely make the processor design and software design more challenging. According to the RISC-V instruction set, they make variations on one instruction, so that the operation to registers or immediate values are recognizable.


## Principle of designing new instruction set

The design of the new instruction set follows several principles as listed below:
* ___Completeness___
* ___Compactness___
* ___User-friendly___
* ___Implementation-friendly___

#### Detailed explanations regarding each principle

__Completeness__ \
According to Wikipedia, the formal definition for Turing completeness is:
> A computational system that can compute every Turing-computable function is called Turing-complete (or Turing-powerful). Alternatively, such a system is one that can simulate a universal Turing machine.

In other words, given infinitely many resources and time, one computer system should be able to compute anything. The new instruction set must be turing complete for it to be useful.

__Compactness__ \








__User-friendly__

__Implementation-friendly__









Below is a full reference of existing (old) instruction set:

| Opcode              | Explanation               | Semantics                     | Type  |
| :------------------ | :------------------------ | :-------------------------    |:----- |
| __ADD__             |   add two operands        | _R1 $\leftarrow$ R2 + R3/imm_ |  R/I  |
| __UMUL__            |   multiple two operands   | _R1 $\leftarrow$ R2 * R3/imm_ |  R/I  |
| __UDIV__            |   divide two operands     | _R1 $\leftarrow$ R2 / R3/imm_ |  R/I  |
| __UMOL__            |   op1 % op2               | _R1 $\leftarrow$ R2 % R3/imm_ |  R/I  |
| __AND__             |   bitwise And of A & B    | _R1 $\leftarrow$ R2 & R3/imm_ |  R/I  |
| __ORR__             |   bitwise Or of A & B     | _R1 $\leftarrow$ R2 \| R3/imm_|  R/I  |
| __XOR__             |   bitwise Xor of A & B    | _R1 $\leftarrow$ R2 ^ R3/imm_ |  R/I  |
| __SHL__             |   logical shift left      | _R1 $\leftarrow$ R2 << R3/imm_|  R/I  |
| __SHR__             |   logical shift right     | _R1 $\leftarrow$ R2 >> R3/imm_|  R/I  |
| __RTL__             |   logical rotate left     | _R1 $\leftarrow$ R2 <~ R3/imm_|  R/I  |
| __RTR__             |   logical rotate right    | _R1 $\leftarrow$ R2 ~> R3/imm_|  R/I  |
| __NOT__             |   comp all the bits       | _R1 $\leftarrow$ ~R2_         |  U    |
| __LDR__             |   load reg from mem       | _R1 $\leftarrow$ [R2]_        |  U    |
| __STR__             |   store reg in mem        | _[R1] $\leftarrow$ R2_        |  U    |
| __PUSH__            |   push reg onto stack     | _[SP - 4] $\leftarrow$ R1_    |  S    |
| __POP__             |   pop top ele into reg    | _R1 $\leftarrow$ [SP] + 4_    |  S    |
| __JMP__             |   unconditional jump      | _N/A_                         |  J    |
| __JZ__              |   jump if Z flag is set   | _N/A_                         |  J    |
| __JC__              |   jump if C flag is set   | _N/A_                         |  J    |
| __JV__              |   jump if V flag is set   | _N/A_                         |  J    |
| __JZN__             |   jump if Z or N is set   | _N/A_                         |  J    |
| __JN__              |   jump if N flag is set   | _N/A_                         |  J    |
| __SYSCALL__         |   invokes system calls    | _N/A_                         |  J    |
